---
title: "Ometa_Organic_Amendment_Meta_Analysis"
output: html_notebook
editor_options: 
  chunk_output_type: console
---

Updated: 20201001 EJF
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
GOAL: 
Meta-analysis on soil organic amendment impact on soil carbon pools > 20cm in depth
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
STATS OVERVIEW:
mixed model for meta-analysis (regression?) with maximum likelihood 
       (hierarchical w study and depth as groups) 
       OR I could run different analyssis every 20cm
       
parameter = carbon stock 
moderators = initial soil conditions, other environmental factors, management
covariate = length of study (months)??
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

```{r, A. (1) prelimary - load packages, include=FALSE}
#include=FALSE supress this output when knitting doc
uzdir<-("/Users/macuser/Dropbox/9Meta_analysis_organic/Statistical_meta_analysis/Ometa2019") #save long name as user directory uzdir
setwd(paste(uzdir))  #set your working directory/file
source(file="EJF_libraries.R") #install packages, use old vegan 
```

```{r, B. load data and subset, response ratio + error calculations, include=FALSE}
#echo=FALSE do not incldue code when knitting doc 
#include=FALSE supress this output when knitting doc

##########################################################################################################
###
### 2. LOAD DATA AND SUBSET
###
##########################################################################################################
#rm(list = ls()) # if you want to reset your environment by deleating everything
df1<-read.csv("Ometa_table.csv", header=T, na.strings= c(""," ", "na", "nd", "NA"), skip=1)
str(df1) 
ncol(df1)
nrow(df1)

#last 4 rows are empty
df1<-df1[-c(4076:4079),]
#colnames(df1)

#number of studies included
length(unique(df1$ACC))
length(unique(df1$country))
df1$X_a<-as.numeric(df1$X_a); df1$X_cf<-as.numeric(df1$X_cf); df1$X_cmin<-as.numeric(df1$X_cmin)
names(df1)
library(dplyr)
#calculate a few new reponse variables to test: (1) combine N input variable (amendment + fertilizer) (2) Calculate percent carbon added = the SOC from the treatment Amend C/SOC (% C added) = Treatment SOC?? 
TN.added<-df$Nfert_rate+df$amend_N_kg.ha
SOC_initial_Mg.ha<- (df$SOC_g.kg /1000) * df$BD *     (df$depth.end-df$depth.start) *
                 # initial C g/g soil    x g / cm3    x cm depth    
            (1000*1000)     / (100000000)
    # [1000 g/kg * 1000kg/Mg / (100 000 000 cm2. ha)
ratio_SOC.amend<- df$C.rate_Mg.ha/SOC_initial_Mg.ha; 
 
df1.5<-cbind(df1, TN.added, ratio_SOC.amend )

names(df1.5)
#select important columns
df1.5 %>% dplyr::select(X3,ACC, 
                      crop_group, crop_system, irrigated, tillage_type , tillage_depth,    
                      till_depth_group, Nfert_rate, Nfert_group,  Pfert_rate, NPK_rate,
                      depth.start ,  depth.end ,  param ,  param_group ,  units , 
                      exp_duration_mos,  duration_group,  duration_even , 
                       lat.dec.degree, country , elevation ,  lat_group , MAT ,  MAP ,
                      pH, clay, clay_group ,  pH_group ,  SOC_g.kg, SOC_int_group, BD,
                      amend, amend_group, weight.dry,  C.rate_Mg.ha, C.N_rate, C.rate_group, ratio_SOC.amend,     
                      amend_N_kg.ha,amend_N_kg.ha_group, TN.added,
                      X_cf, SE_cf, SD_cf, N_cf, X_a, SE_a, SD_a, N_a, X_cmin, SE_cmin, SD_cmin, N_cmin, trt_name ) -> df2 
 

#rename cmin to zf (zero fertilized control)
df<-dplyr::rename(df2, X_zf=X_cmin, SE_zf=SE_cmin, SD_zf=SD_cmin , N_zf=N_cmin)

df %>% dplyr::select(X_cf, SE_cf, SD_cf, N_cf, X_a, SE_a, SD_a, N_a, X_zf, SE_zf, SD_zf, N_zf)-> df.result 

#add additional columns:##
df<-tidyr::unite(df, At, c(ACC, trt_name), sep = "_", remove = FALSE, na.rm = FALSE) # create column of ACC + trt name (ie how many treatments per study = At variable)
df$ACC<-as.factor(df$ACC)

##########################################################################################################
###
### 3. INITIAL PLOTS
###
##########################################################################################################
#plot(df$amend_group_brd, df$C.N_rate) 
dev.off()
plot(as.factor(df$country)); axis(2,cex.axis=1)  
plot(df$depth.end)
plot(as.factor(df$param_group), main="Parameters - Reponse Variables")
plot(as.factor(df$tillage_type), main = "Tillage Groups")
plot(as.factor(df$crop_group), main= "Crop Types")
plot(as.factor(df$crop_system))
hist(df$lat.dec.degree, main= "Latitude")
     hist(df$elevation, main= "Elevation", xlab="Elevation (m)")
     plot(df$MAP, df$MAT)
     #hist(df$year.zero, main="First Year of Study", xlab="Year")
     #hist(df$exp_duration_mos, main="Study Length", xlab="Months of Experiment")
      plot(as.factor(df$duration_even), main="First Year of Study", xlab="Year")
     hist(df$MAP, main="Precipitation", xlab="MAP (mm)")
      hist(df$MAT, main="Temperature", xlab="MAT (degrees C)")
hist(df$clay, main="Percent Clay", xlab="Clay (%)")

plot(as.factor(df$duration_group), main="Study Duration", xlab= "Years")
  #  plot(df$irrigation_group, main ="Cateogry of Irrigation")
   plot(as.factor(df$till_depth_group), main ="Tillage depths")
   hist(df$pH, xlab="pH")  
   plot(as.factor(df$SOC_int_group), main="Initial SOC", xlab="SOC g/kg")

#organic amendment C,N, application rate (min, median, mean, max)
plot(as.factor(df$amend), las=3, cex.names=.5)
plot(as.factor(df$amend_group), las=3, cex.names=.5)
plot(df$weight.dry)
plot(as.factor(df$C.rate_group)); hist(df$C.rate_Mg.ha)
hist(df$C.N_rate); hist(df$amend_N_kg.ha)
boxplot(df$TN.added~df$ACC)
boxplot(df$TN.added~df$amend_group)

boxplot(df$C.rate_Mg.ha~df$amend_group)
boxplot(df$amend_N_kg.ha~df$amend_group)
boxplot(df$C.N_rate~df$amend_group)
boxplot(df$ratio_SOC.amend)

#############################################################################
###
### 4. RESPONSE RATIOS, weights of ratios, % change
###
#############################################################################
#current dataframess = df and df.result 
#calculate SD from SE= SD/ sqrt(n)  => SE*sqrt(n)

#if the value is Na, replace with SD calculated from SE
SD.to.replace<-which(is.na(df$SD_a)); length(SD.to.replace) #of 4079 obs
df$StDev_a<-df$SD_a
df$StDev_a<-ifelse(is.na(df$StDev_a),  #if SD = NA
         df[SD.to.replace ,]$SE_a * sqrt(df[SD.to.replace, ]$N_a), #replace with SE * sqrt of n
       df$StDev_a)

#calculate the weight of each study based off of observation numbers (Hedges adn Olkin 1985)
  df$w_cf<-(df$N_a*df$N_cf)/(df$N_a+df$N_cf)
  df$w_zf<-(df$N_a*df$N_zf)/(df$N_a+df$N_zf)

which(is.na(df$N_a))
which(is.na(df$N_zf))
which(is.na(df$N_a))
which(is.na(df$N_zf))
  
#calculate response ratio for each observation:
ratio_zf<-log(df$X_a/df$X_zf)
   nan.check<-df[which(is.nan(ratio_zf)), ]; names(nan.check) #determine which values are NaN
   nan.check[c(6, 24:ncol(nan.check))] #print which values are NaN
    percent.change.zf<-(exp(ratio_zf) -1)*100 #mean % change = (e^ln(rr)-1)*100
    
ratio_cf<-log(df$X_a/df$X_cf)
    percent.change.cf<-(exp(ratio_cf)-1)*100 

#create new df.ratio with ratios calculated for each obs
df.r<-cbind(df, ratio_zf, percent.change.zf, ratio_cf, percent.change.cf) #create df with response ratios

#remove NaNs/ Inf
is.na(df.r$ratio_zf) <- is.infinite(df.r$ratio_zf)
is.na(df.r$ratio_zf) <- is.nan(df.r$ratio_zf)
is.na(df.r$ratio_cf) <- is.infinite(df.r$ratio_cf)
is.na(df.r$ratio_cf) <- is.nan(df.r$cf_zf) 

#remove NA response ratios
#df.r:  which factors have NAs?
which(is.na(df.r$MAT))
which(is.na(df.r$MAP))
length(unique(df.c[which(is.na(df.r$pH)), ]$ACC)) #many NAs (13 studies)
     (unique(df.c[which(is.na(df.r$pH)), ]$ACC)) 
length(unique(df.c[which(is.na(df.c$clay)), ]$ACC)) #many NAs (22)
     (unique(df.c[which(is.na(df.c$clay)), ]$ACC))
length(unique(df.c[which(is.na(df.c$SOC_g.kg)), ]$ACC)) #21
     (unique(df.c[which(is.na(df.c$SOC_g.kg)), ]$ACC)) 
length(unique(df.c[which(is.na(df.c$C.rate_Mg.ha)), ]$ACC)) #24
     (unique(df.c[which(is.na(df.c$C.rate_Mg.ha)), ]$ACC)) #24
length(unique(df.c[which(is.na(df.c$amend_N_kg.ha)), ]$ACC)) #21
     (unique(df.c[which(is.na(df.c$amend_N_kg.ha)), ]$ACC)) #21
length(unique(df.c[which(is.na(df.c$Nfert_rate)), ]$ACC)) #16
      (unique(df.c[which(is.na(df.c$Nfert_rate)), ]$ACC))

which(is.na(df.c$SOC_g.kg))  #many NAs
which(is.na(df.c$C.re_Mg.ha)) #many NAs
which(is.na(df.c$amend_N_kg.ha)) #many NAs
which(is.na(df.c$Nfert_rate)) #many NAs

#subset by zero or fertilized controls
#remove rows with NA for response ratio - as these obvs cannot be analyzed
mydf.cf<-df.c[which(!is.na(df.c$ratio_cf)),]  
mydf.zf<-mydf.zf<-df.c[which(!is.na(df.c$ratio_zf)),]

##########################################################################################################
###
### 5. IMPUTE ERROR
###
##########################################################################################################
#impute error over all depths/amendments 

str(df.r) #4075 obs
#estimate ratio to impute error for amend trt / cf control / zf control
est.SD.a<-sum(df.r$SD_a, na.rm=T)/sum(df.r$X_a,na.rm=T)
est.SD.cf<-sum(df.r$SD_cf, na.rm=T)/sum(df.r$X_cf, na.rm=T)
est.SD.zf<-sum(df.r$SD_zf, na.rm=T)/sum(df.r$X_zf, na.rm=T)

#ratio of SD/X (est.XXX) * mean to impute error (FYI, must use is.na not df.r$X=="NA" (won't return a TRUE, just na and ifelse doesn't work))
df.r$SD_a_imp<-ifelse(is.na(df.r$SD_a), yes=df.r$X_a*est.SD.a, no=df.r$SD_a)
df.r$SD_cf_imp<-ifelse(is.na(df.r$SD_cf), df.r$X_cf*est.SD.cf, df.r$SD_cf)
df.r$SD_zf_imp<-ifelse(is.na(df.r$SD_zf), df.r$X_zf*est.SD.zf, df.r$SD_zf)

#amendment errors reported
error.amend<-(1-length(which(is.na(df.r$StDev_a)))/nrow(df.r))*100; error.amend #30% have error reported, for SOC 36% have error reported

#impute error via regression S = alpha +beta(n)
  lm(df.r$SD_cf ~ df.r$N_cf, na.action=na.omit) #cf intercept/alpha= 26.430 m/beta= -6.166
 lm(df.r$SD_zf ~ df.r$N_zf, na.action=na.omit) #zf intercept/alpha= 12.210 m/beta= -2.461 
  lm(df.r$SD_a ~ df.r$N_a, na.action=na.omit) #a intercept/alpha= 25.731 and m/beta=-5.496

#regression to impute error save as new column
df.r$SD_cf_reg<-ifelse(is.na(df.r$SD_cf), 26.430-6.166*(df.r$N_cf), df.r$SD_cf)
df.r$SD_zf_reg<-ifelse(is.na(df.r$SD_zf), 12.210-2.461*(df.r$N_zf), df.r$SD_zf)
df.r$SD_a_reg<-ifelse(is.na(df.r$SD_a), 25.731-5.496*(df.r$N_a), df.r$SD_a)

### create column of response ratios with fertilized controls as main effects, and only use zero controls when other option not possible
#dataframes with non NAs for fert and zero controls = mydf.fert; mydf.zf and combined
str(df.r)
mydf.cf$ratio_comb<-mydf.cf$ratio_cf
mydf.zf$ratio_comb<-mydf.zf$ratio_zf
mydf.cf$SD_all<-mydf.cf$SD_cf_imp
mydf.zf$SD_all<-mydf.zf$SD_zf_imp
mydf.cf$w_all<-mydf.cf$w_cf
mydf.zf$w_all<-mydf.zf$w_zf 

names(df.r)
#to combine datasets - use fertilized controls when possible= had a lower effect size (will not overestimate the effect?)
#left outer join into the df.r dataframe
 df.r$ratio_all<-ifelse(is.na(df.r$ratio_cf),  df.r$ratio_zf, df.r$ratio_cf)
  df.r$SD_all<-ifelse(is.na(df.r$ratio_cf), df.r$SD_zf_imp, df.r$SD_cf_imp) #imputed std deviations
  df.r$w_all<-ifelse(is.na(df.r$ratio_cf), df.r$w_zf, df.r$w_cf)
df.r$control.type<-ifelse(is.na(df.r$ratio_cf), "zf", "cf")

#where are the outliers? for ratio.zf and ratio.cf
#mean.ratio<- df.r %>%
#  group_by(ACC) %>%
#  summarise(mean.f = mean(ratio_cf),
#            mean.zf = mean(ratio_zf), n= n()); mean.ratio

#mean.ratio<- df.r %>%
#  group_by(ACC) %>%
#summarise_all(funs(mean, n), na.rm = TRUE); mean.ratio

# create depth sub grrups
#create one depth variable, mean of depth start and stop
df.r$depth<-(df.r$depth.end+df.r$depth.start)/2 
mean(df.r$depth, na.rm=T)
sd(df.r$depth, na.rm=T)
max(df.r$depth, na.rm=T)

##########################################################################################################
###
### 5. Subset and CALCULATE SOIL CARBON STOCKS
###
##########################################################################################################
df.c<-subset(df.r, param == "SOC" ); str(df.c) #subset by carbon parameters only, obs=451

#calculate carbon stocks from g.kg  (g.kg/1000)*BD*(depth.end-depth.start) = g/cm2
# Convert to t/ha => g/cm2 * (1Mg/ 1,000,000g)*(1*10^8cm2/ha) = 100
   #(1/1000000)*(1*10^8/1) 
## Note from CK re: stock conversation: many studies did not report change in BD btw treatments, so stock change is just a multiple of % change or other measurement; may not be correct to report since we would assume BD should change with ammendment addition. 
df.c$X_a_stock<-ifelse(df.c$units == "g.kg", 
                       df.c$X_a/1000 * df.c$BD * (df.c$depth.end-df.c$depth.start) * 100, 
                       df.c$X_a/1000) #else divides the kg/ha by 1000 to get Mg/ha
df.c$X_zf_stock<-ifelse(df.c$units == "g.kg", 
                       df.c$X_zf/1000 * df.c$BD * (df.c$depth.end-df.c$depth.start) * 100, 
                       df.c$X_zf/1000) #else divides the kg/ha by 1000 to get Mg/ha
df.c$X_cf_stock<-ifelse(df.c$units == "g.kg", 
                       df.c$X_cf/1000 * df.c$BD * (df.c$depth.end-df.c$depth.start) * 100, 
                       df.c$X_cf/1000) #else divides the kg/ha by 1000 to get Mg/ha
  
#convert error to metric t/ha (or Mg/ha)
df.c$SD_a_stock<-ifelse(df.c$units == "g.kg", 
                       df.c$SD_a/1000 * df.c$BD * (df.c$depth.end-df.c$depth.start) * 100, 
                       df.c$SD_a/1000) #else divides the kg/ha by 1000 to get Mg/ha
df.c$SD_zf_stock<-ifelse(df.c$units == "g.kg", 
                       df.c$SD_zf/1000 * df.c$BD * (df.c$depth.end-df.c$depth.start) * 100, 
                       df.c$SD_zf/1000) #else divides the kg/ha by 1000 to get Mg/ha
df.c$SD_cf_stock<-ifelse(df.c$units == "g.kg", 
                       df.c$SD_cf/1000 * df.c$BD * (df.c$depth.end-df.c$depth.start) * 100, 
                       df.c$SD_cf/1000) #else divides the kg/ha by 1000 to get Mg/ha

mean(df.c$ratio_cf, na.rm=TRUE); 
mean(df.c$ratio_zf, na.rm=TRUE) #higher ratio with zero-fertilizer on controls
```

```{r C. meta-anlaysis models}
##########################################################################################################
###
### 5. SUBSET RESPONSE VARIABLES
###
##########################################################################################################
#df.r has the response ratios calculated for zero and fertilized controls
    #ratio_all contains fertilized plots when possible, zero input plots otherwise (as to not overestimate the response)
 
#many data types are extracted, select soil carbon as the initial response parameter
 #subgroups will be used to addresss questions about stability
param<- unique( df.r[order(df.r$param), ]$param ); param
  #create loop for number of observations
   df.r[which(df.r$param=="SOC"), ]$At

write.csv(param, "Ometa_parameters.csv")
  df.r[which(df.r$param=="SOC"|df.r$param=="C"), ]$ACC %>% unique() %>% length() #SOC = 49
  
#check number of studies that will add to 
df.r[which(df.r$param=="SOC"), ]$ACC %>% unique() %>% length() #ALL DATA->>SOC ACC= 45
     df.r[which(df.r$param=="SOC"), ]$At %>% unique() %>% length() #ALL DATA->>SOC Atrt= 108
 df.r[which(df.r$param=="POM"| df.r$param=="LF" |df.r$param=="C_POM"), ]$ACC %>% unique() %>% length() #ALL DATA->>LF+POM+C_POM  ACC= 4
     df.r[which(df.r$param=="POM"| df.r$param=="LF" |df.r$param=="C_POM"), ]$At %>% unique() %>% length() #ALL DATA->>LF+POM+C_POM  Atrt= 13
 df.r[which(df.r$param=="C_MAOM" | df.r$param=="MAOM"), ]$ACC %>% unique() %>% length() #ALL DATA->>MAOM ACC = 3
    length( which(df.r$param=="C_MAOM" | df.r$param=="MAOM") )                     #ALL DATA->>MAOM n=19 
 df.r[which(df.r$param_group=="crop"), ]$ACC %>% unique() %>% length() #ALL DATA->> crop = 20 ACC
 df.r[which(grepl("yield", df.r$param)), ]$ACC %>% unique() %>% length() #ALL DATA->> yield = 17 ACC
 df.r[which(grepl("biomass", df.r$param)), ]$ACC %>% unique() %>% length() #ALL DATA->> biomass = 8 ACC
      df.r[which(grepl("root", df.r$param)), ] %>% nrow()  #ALL DATA->> root = 4 ACC, 9 observations
 df.r[which(df.r$param_group=="N"), ]$ACC %>% unique() %>% length() #ALL DATA->> N group ACC = 36
      length( which(df.r$param_group=="N") ) #ALL DATA->> N group ACC = 790 obs 
      
#response variables for the df.test data: OC, POMC, MAOM_C, POM_N, MAOM_N, TN, yield
    df.c
df.n  <-df.r[which(df.r$param =="N"), ]; length(df.n) ; unique(df.n$param)
   #df.n<-df.r[which(grepl("N", df.r$param)), ]; length(df.n) ; unique(df.n$param)
df.POM  <-subset(df.r, param == "POM" |param == "LF"|param == "C_POM" ); length(unique(df.POM$At)); 
    #length(unique(df.POM$ACC))
    #df.POM<-df.r[which(grepl("POM", df.r$param)), ]; length(df.POM) ; unique(df.POM$param)
#df.MAOM<-subset(df.r, param == "MAOM" |param == "SOC_s+c"| param == "C_MAOM" ); length(unique(df.MAOM$At)); length(unique(df.MAOM$ACC))
    df.MAOM<-df.r[which(grepl("MAOM", df.r$param)), ]; length(df.MAOM) ; unique(df.MAOM$param)
   df.yield<-df.r[which(grepl("yield", df.r$param)), ]; length(df.yield) ; unique(df.yield$param)
   
df.names<-c("df.c", "df.n", "df.POM", "df.MAOM", "df.yield")

##########################################################################################################
###
### 7. RMA regression model
###
##########################################################################################################

#choose a parameter to test (df.c, df.n, df. )
df.names #list all dataframe names
df.p<-df.MAOM

#create subset data frames by depth increment -> categorize based on mean of dpeth increment - note that original df.r which has RR's and %change calcs
df15<-subset(df.p, depth <= 15); nrow(df15) #subset by depth 0-15
df30<-subset(df.p, depth <= 30 & depth > 15); nrow(df30) #subset by depth 15-30cm
df60<-subset(df.p, depth <= 60 & depth > 30); nrow(df60) #subset by depth 30-60cm
df90<-subset(df.p, depth <= 90 & depth > 60); nrow(df90) #subset by depth 60-90cm

#############
#choose a depth to check
dft<-df15; paste("Unique treatment observations:", length(unique(dft$At)) ) #number of observations
#############

#check normality of ratio distribution 
f<-dft$ratio_cf; z<-dft$ratio_zf; all<-(dft$ratio_all ) 
# f<-log(dft$ratio_cf+1);  z<-log(dft$ratio_zf+1);all<-log(dft$ratio_all+1)


hist(f); hist(z); hist(all)
qqnorm(f);qqline(f) #1 outlier 
qqnorm(z);qqline(z)
qqnorm(all); qqline(all)
#dft$ratio_all[dft$ratio_all >1.9] <-"NA"; dft$ratio_all<-as.numeric(dft$ratio_all) #make ratio_all numeric, after adding the NA

## Some quick stats/analysis with subgroups created
#average RR in each subgroup

mean(na.omit(dft$ratio_all))#average RR for 0-15 depth .18

#quick test of subsets data using model from below
  names(dft)
  
rma.all1 <- rma.mv(ratio_all, V=SD_all, 
             mods = ~ amend, random= ~1|ACC,
            data=dft, W=w_all, method="ML"); rma.all1 #only including
  shapiro.test(resid(rma.all));
  
  
rma.all2 <- rma.mv(ratio_all, V=SD_all, 
             mods = ~ MAT+ MAP+ pH+ clay+ SOC_g.kg + #latitude.dec.degree + exp_duration_mos + C.N_rate
                  C.rate_Mg.ha+ TN.added, random= ~1|ACC,
            data=dft, W=w_all, method="ML"); rma.all2 #only including
   shapiro.test(resid(rma.all2))
  qqnorm(resid(rma.all2)); qqline(resid(rma.all2))
 
rma.cf <- rma.mv(ratio_cf, V=SD_cf, 
             mods = ~ MAT+ MAP+ pH+ clay+ SOC_g.kg + #latitude.dec.degree + exp_duration_mos + C.N_rate
                  C.rate_Mg.ha+ TN.added, random= ~1|ACC,
            data=dft, W=w_cf, method="ML"); rma.cf #only including

dft$w_zf
rma.zf <- rma.mv(ratio_zf, V=SD_zf, 
             mods = ~ MAT+ MAP+ pH+ clay+ SOC_g.kg + #latitude.dec.degree + exp_duration_mos + C.N_rate
                  C.rate_Mg.ha+ TN.added, random= ~1|ACC,
            data=dft, W=w_zf, method="ML"); rma.zf #only including


length(unique(df.c[which(df.c$amend=="manure"), ]$ACC))
unique(df.c[which(df.c$amend=="residue"), ]$C.rate_Mg.ha)

length(unique(df.c$ACC))






###### Bootstrapping code

#create function to resample with
boot_mean <- function(df_vector, resample_indices) {
    mean(df_vector[resample_indices])
}
#boot_var <- function(df_vector, resample_indices) {
#    (sd(df_vector[resample_indices])^2 )
#}
set.seed(12345)
#moderators of interest: exp_duration_mos, amend_group, clay, lat.dec.degree

#########################################
# 7a. data frame with fertilized controls 
#########################################
mean(mydf.cf$ratio_cf) #mean response ratio
#mean(mydf.cf$ratio_cf)-1 #percent change RR=1 no effect (Kallenbach)
mean(mydf.cf$percent.change.cf) #percent change (Pressler 2018)

results.cf <- boot(data=mydf.cf$ratio_cf, statistic=boot_mean, R=1000, weights=mydf.cf$w_cf) # dist looks more evenly distriuted around mean without the weights
                #formula=ratio_cf~depth) #strata=ACC?depth?
plot(results.cf)
summary(results.cf) #mean RR = 0.14866
boot.ci(results.cf) #,type="bca") #significant if do not inclue 1
 #Pnormale 95%    ( 0.1569,  0.2054 )

#percetn lower or higher than observed mean
Higher<- length (which( results.cf$t >mean(summary(results.cf)$original)) )/length(results.cf$t)
Lower <-length (which(results.cf$t < mean(summary(results.cf)$original)) )/length(results.cf$t)
meanLrgerData<-summary(results.cf)$original > results.cf$data
  ifelse( length(which(meanLrgerData))> .5*length(meanLrgerData), "Need to bias correct", "Great work!")
str(results.cf)
#########################################
# 7b. data frame control zero/minimum inputs
#########################################

#moderators of interest: exp_duration_mos, amend_group, clay, lat.dec.degree
 
mean(mydf.zf$ratio_zf) # mean RR
#mean(mydf.zf$ratio_zf)-1 #percent change (Kallenbach 2011)
mean(mydf.zf$percent.change.zf) #percent change (Pressler 2018)

results.zf <- boot(data=mydf.zf$ratio_zf, statistic=boot_mean, R=1000, weights=mydf.zf$w_zf)
                #formula=ratio_cf~depth) #strata=ACC?depth?
plot(results.zf)

boot.ci(results.zf) #, type="bca") #bias corrected?
summary(results.zf)
meanLrgerData<-summary(results.zf)$original > results.zf$data
  ifelse( length(which(meanLrgerData))> .5*length(meanLrgerData), "Need to bias correct", "Great work!")
  
str(results.zf)
#formula=ratio_cf~depth) #strata=ACC?depth?


### PLOTS
# CF 0.14866 ( 0.1569,  0.2054 )
# ZF 0.067939 ( 0.0657,  0.0868 )

y1=.25; y2=.75
plot(.068184, y1 ,ylab="Study type", xlab="Effect Size", xlim=c(-.5,.5), ylim=c(0,1), 
     pch=16, cex=1); abline(v=0)
arrows(y0=y1, x0=0.0652, y1=y1, x1=0.0868, code=3, angle=90, length=.05, col="black") #error bars
points(.14995, y2)
arrows(y0=y2, x0=0.1569, y1=y2, x1=0.2054, code=3, angle=90, length=.05, col="blue") #error bars
 
##########################################################################################################
###
### 8. Q = check heterogeneity of studies in meta-analysis
###
##########################################################################################################
#see pg 109-113 Koricheva 2013 handbook of meta-anaysis for ecology
#check QT using K against chi-sq distrubtion: https://www.socscistatistics.com/pvalues/chidistribution.aspx
  #note random effects models should take this QT between study heterogeniety into account, 

### so QT is not a useful statistic for the global meta-analysis with random effects###

#check signficant against the X2 distribution:
# http://hamelg.blogspot.com/2015/08/introduction-to-r-part-25-chi-squared.html

#mu.hat = sum(w.k*theta.k)/sum(w.k)
#QT = sum (w.k* (theta.k-mu.hat)^2)
#I2 = max ((100*( (QT-(K-1))/QT)),0)
#########################################
#8a. fertilized controls
#########################################
w_cf<-mydf.cf$w_cf 
theta.cf<-mydf.cf$ratio_cf
mu.cf <- sum(w_cf*theta.cf)/sum(w_cf) #0.1495921; % change 16.13
QT.cf <- sum (w_cf* (theta.cf-mu.cf)^2) #not meaningful for random effects models, compare to X2 distrubtion, 50.09 (X2 p-value = .18 , not sig )

K.cf <- length(unique(mydf.cf$ACC)) #42
I2.cf = max ((100*( (QT.cf-(K.cf-1))/QT.cf)),0)
#18% of observed variance can be attribted to difference among the studies
     #rerea 3.18.20 and found 5% explained

 #chisq.test(x = observed(theta.cf), p = expected)
1-pchisq(q=QT.cf, df=(K.cf-1)) #ACC not significant
1-pchisq(q=I2.cf, df=(K.cf-1))

#########################################
#8b. zero input controls
#########################################
w_zf<-mydf.zf$w_zf 
theta.zf<-mydf.zf$ratio_zf; hist(theta.zf); shapiro.test(theta.zf)
mu.zf <- sum(w_zf*theta.zf)/sum(w_zf) #0.2792475; %change 32.21
QT.zf <- sum (w_zf* (theta.zf-mu.zf)^2) #looked up X2 p-value = 0.2236, not sig
K.zf <- length(unique(mydf.zf$ACC)) #39
I2.zf = max ((100*( (QT.zf-(K.zf-1))/QT.zf)),0)
#16% of observed variance can be attribted to difference among the studies

#get p-value, testing backtransformed ratios against X2 distribution with K-1 for df
 1-pchisq(q=QT.zf, df=(K.zf-1)) #ACC is not significant
 1-pchisq(q=I2.zf, df=(K.zf-1)) #ACC not significant - not sure if this test makes statistical sense, just curious
 
#########################################
#8c. combined (all) controls
#########################################
w.comb<-c(mean(w_cf), mean(w_zf))
theta.comb<-c(mean(theta.cf), mean(theta.zf))
mu.comb<-c(mean(mu.cf), mean(mu.zf))
QT.comb<-sum(QT.cf, QT.zf)
K.comb <- sum(K.zf, K.cf) #81
I2.comb = max ((100*( (QT.comb-(K.comb-1))/QT.comb)),0) #16.2% of variance explained by ACC
 #chisq.test
 1-pchisq(q=QT.comb, df=(K.comb-1)) #not significant
1-pchisq(q=I2.comb, df=(K.comb-1)) #not significant
```

```{r, C. Graphs + Check regression assumptions and for correlation among parameters}
####################################################################################################
###
### 10. Check 4 assumptions of regression  https://peerj.com/articles/3323/
### (linearity, normality of error, homoscedasticity - plot resid, independence of error)
###      (10 assumptions listed here:
####################################################################################################
names(df.c)

#continuous: C.rate_Mg.ha, C.N_rate, N.amend_g.kg,ç, Nfert_rate
   #env continuous: MAT, MAP, MAP/MAT, lat.dec.degree
    #initial continuous: SOC_g.kg, pH, clay

#factor: At, crop_group, crop_system, irrigated, tillage_type, till_depth_group, Nfert_group, duration_group, duration_even, country,
# lat_group, clay_group, pH_group, SOC_int_group, amend, amend_group, C.rate_group, amend_N_kg.ha_group

#subgroup analysis???
levels(df.c$crop_group)
levels(df.c$crop_system)
levels(df.c$tillage_type)
# exp_duration_mos

#set up linear model  #yield? #total amount of C added over the experiment
rma1 <- rma.mv(ratio_all, V=SD_all, 
             mods = ~ MAT+ MAP+ pH+ clay+ SOC_g.kg + #latitude.dec.degree + exp_duration_mos + C.N_rate
                  C.rate_Mg.ha+ amend_N_kg.ha + Nfert_rate, random= ~1|ACC,
            data=df.c, W=w_all, method="ML"); rma1 #important to use ML (instead of REML) estimation, since log-likelihoods (& hence information criteria) are not directly comparable for models with different fixed effects

names(df.c)
df.c$pH
#Erika which factors have NAs
which(is.na(df.c$MAT))
which(is.na(df.c$MAP))
length(unique(df.c[which(is.na(df.c$pH)), ]$ACC)) #many NAs (13 studies)
length(unique(df.c[which(is.na(df.c$clay)), ]$ACC)) #many NAs
which(is.na(df.c$SOC_g.kg))  #many NAs
which(is.na(df.c$C.rate_Mg.ha)) #many NAs
which(is.na(df.c$amend_N_kg.ha)) #many NAs
which(is.na(df.c$Nfert_rate)) #many NAs

which(is.na(df.c$pH))

#install.packages("broom")
library(broom) #testing plots to check assumptions - didn't run with rma output
 #model.diag.metrics <- augment(rma1); head(model.diag.metrics)
 
#graph residuals
#ggplot(model.diag.metrics, aes(youtube, sales)) +
#  geom_point() +
#  stat_smooth(method = lm, se = FALSE) +
#  geom_segment(aes(xend = youtube, yend = .fitted), color = "red", size = 0.3)

#########################################
# 10a. correlation of covariates minimized (multicolinearity)
#########################################
param.corr<-select(df, MAT, MAP, lat.dec.degree, elevation, pH, clay, SOC_g.kg,
                  C.rate_Mg.ha, C.N_rate, amend_N_kg.ha, exp_duration_mos, Nfert_rate)
param.corr$MAT.MAP<-df$MAT/df$MAP
names(df.c)
pear<-rcorr(as.matrix(param.corr), type = "pearson") ; pear
#CORRELATED: pH and MAT = .98 and MAT/MAP =.65; 
           #elevation and exp_duration_mos (.97); elevation and MAT.MAP .76,  lat and Nfert.rate .333 + amend_N =.32;
# !!! remove elevation and MAT !!!

#########################################
# 10b. test normality of errors
#########################################
res1<-residuals(rma1); hist(res1) #residuals normally distributed around 0
qqnorm(res1); qqline(res1); shapiro.test(res1) #check normality of residuals
mean(res1, na.rm=T) #check mean of resid = ~0

#########################################
# 10c. test homoscedasticity of variance
#########################################
plot(res1); abline(0,0)

#also see plots in section 11

#########################################
# 10d. test independence of residuals (autocorrelations)
#########################################
acf(res1) #on plot if there is acorrelation = 1, no correlation = 0
 #cor.test(df$MAP, res1) #reject null, alternative = true correlation not equal 0

```

```{r, 11.  Graphs of response ratios}
### USING ACC ###
#########################################
### 11a GRAPHS OF RESPONSE RATIOS ie, plot within study variance w/ ACC
#########################################
y<-df.c$ratio_all
x<-as.numeric(unique(df.c$ACC))
trt<-levels(df.c$trt_name)

M = tapply(y,
           INDEX = df.c$ACC,
           FUN   = mean, na.rm=T)

SD = tapply(y,
           INDEX = df.c$ACC,
           FUN   = sd, na.rm=T); length(SD); length(x); length(M)

MA<-mean(df.c$ratio_all, na.rm=T)
SDA<-sd(df.c$ratio_all, na.rm=T) 
plot.new()
### ALL plot means and sd of each study
plot(M, x,ylab="ACC", xlab="Effect Size", xlim=c(-1,1), ylim=c(-5,50), 
     pch=16, cex=.001)
 abline(v=0); abline(v=MA, lty=2, col="blue", lwd=2)

y_grand.mean<-(-3)
 arrows(y0=x, x0=M-SD, y1=x, x1=M+SD, code=3, angle=90, length=0.025, col="darkgray") #error bars
 arrows(y0=y_grand.mean, x0=MA-SDA, y1=y_grand.mean, x1=MA+SDA, code=3, angle=90, length=0.025, lty=2, col="blue") #1150 is the 'pretend' ACC to plot the grand mean

points(M, x,pch=16,cex=.75)
points(MA, y_grand.mean, col="blue", pch=5,cex=2)

(exp(MA)-1)*100 # % change with amendment

#########################################
### 11b plot zero controls only w/ ACC (!!! CURRENTLY NOT WORKING !!!)
#########################################
y<-mydf.zf$ratio_zf
x<-levels(mydf.zf$ACC)
   
M = tapply(y,
           INDEX = mydf.zf$ACC,
           FUN   = mean, na.rm=T)

SD = tapply(y,
           INDEX = mydf.zf$ACC,
           FUN   = sd, na.rm=T); length(SD); length(x); length(M)

MA<-mean(mydf.zf$ratio_zf, na.rm=T)
SDA<-sd(mydf.zf$ratio_zf, na.rm=T) 

### ZERO plot means and sd of each study
plot(M, x,ylab="ACC", xlab="Effect Size",
       pch=16, cex=.001, xlim=c(-1,1), ylim=(c(200,1200)) )
 abline(v=0); abline(v=MA, lty=2, col="blue", lwd=2)

 y.mean<-1150
 arrows(y0=x, x0=M-SD, y1=x, x1=M+SD, code=3, angle=90, length=0.025, col="darkgray") #error bars
 arrows(y0=y.mean, x0=MA-SDA, y1=y.mean, x1=MA+SDA, code=3, angle=90, length=0.025, lty=2, col="blue") #1150 is the 'pretend' ACC to plot the grand mean

points(M, x,pch=16,cex=.75)
points(MA, y.mean, col="blue", pch=5,cex=2)

(exp(MA)-1)*100 # % change with amendment 32% for zero fertilized controls

#########################################
### 11c plot controls w fertilizer w/ ACC !!! CURRENTLY NOT WORKING - DIFFERENT LENGTH OF X !!!
#########################################
y<-mydf.cf$ratio_cf
x<-unique(mydf.cf$ACC)
   
M = tapply(y,
           INDEX = mydf.cf$ACC,
           FUN   = mean, na.rm=T)

SD = tapply(y,
           INDEX = mydf.cf$ACC,
           FUN   = sd, na.rm=T); length(SD); length(x); length(M) #x is 42, not 49

MA<-mean(mydf.cf$ratio_cf, na.rm=T)
SDA<-sd(mydf.cf$ratio_cf, na.rm=T) 

plot.new()
### FERTILIZED CONTROL plot means and sd of each study
plot(M, x,ylab="ACC", xlab="Effect Size",
       pch=16, cex=.001, xlim=c(-1,1), ylim=(c(200,1200)) )
 abline(v=0); abline(v=MA, lty=2, col="red", lwd=2)

 arrows(y0=x, x0=M-SD, y1=x, x1=M+SD, code=3, angle=90, length=0.025, col="darkgray") #error bars
 arrows(y0=1150, x0=MA-SDA, y1=1150, x1=MA+SDA, code=3, angle=90, length=0.025, lty=2, col="red") #1150 is the 'pretend' ACC to plot the grand mean

points(M, x,pch=16,cex=.75)
points(MA, 1150, col="red", pch=5,cex=2)

(exp(MA)-1)*100 # % change with amendment 17% for fertilized controls (32% for zero-fertilized controls)

### USING ACC + Treatment name ###
#########################################
### 11d GRAPHS OF RESPONSE RATIOS ie, plot within study variance ACC+trt
#########################################
y<-df.c$ratio_all
x<-seq(1,length(unique(df.c$At)),1) #create a sequence of numbers to represent the ACC+trt
str(df.c$At)
trt<-levels(df.c$trt_name)

M = as.numeric(tapply(y,
           INDEX = df.c$At,
           FUN   = mean, na.rm=T))

SD = as.numeric(tapply(y,
           INDEX = df.c$At,
           FUN   = sd, na.rm=T))

length(SD); length(x); length(M)

str(SD)
MA<-mean(df.c$ratio_all, na.rm=T)
SDA<-sd(df.c$ratio_all, na.rm=T) 
plot.new()
### ALL plot means and sd of each study ACC+trt
plot(M, x, ylab="ACC & Treatments", xlab="Effect Size (all)",
      xlim=c(-1,1), ylim=(c(0,130)),
       pch=16, cex=.001)
 abline(v=0); abline(v=MA, lty=2, col="blue", lwd=2)
yforAT<-130 #125 is the 'pretend' At to plot the grand mean
   arrows(y0=x, x0=M-SD, y1=x, x1=M+SD, code=3, angle=90, length=0.025, col="darkgray") #error bars
   arrows(y0=yforAT, x0=MA-SDA, y1=yforAT, x1=MA+SDA, code=3, angle=90, length=0.025, lty=2, col="blue") 
points(M, x,pch=16,cex=.75)
points(MA, yforAT, col="blue", pch=5,cex=2)

(exp(MA)-1)*100 # % change with amendment

#########################################
### 11e plot zero controls only  ACC+trt !!! NOT WORKING,  X and Y lengths differ, need to edit !!!
#########################################
y<-subset(df.c, control.type="zf")$ratio_zf
x<-seq(1,length(unique(mydf.cf$At)),1)

M = as.numeric(tapply(y,
           INDEX = mydf.zf$At,
           FUN   = mean, na.rm=T))

SD = as.numeric(tapply(y,
           INDEX = mydf.zf$At,
           FUN   = sd, na.rm=T)); length(SD); length(x); length(M)

MA<-mean(mydf.zf$ratio_zf, na.rm=T)
SDA<-sd(mydf.zf$ratio_zf, na.rm=T) 

### ZERO plot means and sd of each study  
plot(M, x, ylab="ACC & Treatments", xlab="Effect Size",
      xlim=c(-2,2), ylim=(c(0,130)),
       pch=16, cex=.001)
 abline(v=0); abline(v=MA, lty=2, col="blue", lwd=2)

 yforAT<-125
 arrows(y0=x, x0=M-SD, y1=x, x1=M+SD, code=3, angle=90, length=0.025, col="darkgray") #error bars
 arrows(y0=yforAT, x0=MA-SDA, y1=yforAT, x1=MA+SDA, code=3, angle=90, length=0.025, lty=2, col="blue") #1150 is the 'pretend' At to plot the grand mean

points(M, x,pch=16,cex=.75)
points(MA, 125, col="blue", pch=5,cex=2)
(exp(MA)-1)*100 # % change with amendment 32% for zero fertilized controls

#########################################
### 11f plot controls w fertilizer ACC+trt !!! NEEDS A FEW EDITS FOR 'POLISHED' GRAPH !!!
#########################################
y<-mydf.cf$ratio_cf
x<-seq(1,length(unique(mydf.cf$At)),1)
   
M = as.numeric(tapply(y,
           INDEX = mydf.cf$At,
           FUN   = mean, na.rm=T))

SD = as.numeric(tapply(y,
           INDEX = mydf.cf$At,
           FUN   = sd, na.rm=T)); length(SD); length(x); length(M)

MA<-mean(mydf.cf$ratio_cf, na.rm=T)
SDA<-sd(mydf.cf$ratio_cf, na.rm=T) 

### FERTILIZED CONTROL plot means and sd of each study
plot.new()
plot(M, x,ylab="ACC & Treatments", xlab="Effect Size",
       pch=16, cex=.001, xlim=c(-1.5,1.5), ylim=(c(0,100)) )
 abline(v=0); abline(v=MA, lty=2, col="red", lwd=2)

 
 arrows(y0=x, x0=M-SD, y1=x, x1=M+SD, code=3, angle=90, length=0.025, col="darkgray") #error bars
 arrows(y0=95, x0=MA-SDA, y1=95, x1=MA+SDA, code=3, angle=90, length=0.025, lty=2, col="blue") #95 is the 'pretend' At to plot the grand mean
 points(M, x,pch=16,cex=.75)
points(MA, 95, col="blue", pch=5,cex=2)
```

```{r E. IN PROGRESS CODE: Bootstrap Q values}
##########################################################################################################
### IN PROGRESS STARTING WITH THIS SECTION......
### 12. calc Qb for all paramters
###
#########################################################################################################
# bootstrap example with forumula
#https://stats.stackexchange.com/questions/298506/bias-corrected-percentile-confidence-intervals

#loop through variables
#Management
#crop_group + irrigation +crop_system + duration_even + C.rate_group + amend_N_kg.ha_group + amend_group + 
    #amend C:N 

#Environment: Soil properties 
#lat_group +clay_group + pH_group + SOC_int_group + MAP +sand_group(?)
      # + irrigation +crop_system + duration_even + C.rate_group + amend_N_kg.ha_group + amend_group + 
     #lat_group +clay_group + pH_group + SOC_int_group + MAP +sand_group

mods1<- c(names(df.c)[c(1:42)], "trt_name", "control.type", "depth")


#combined fertlized and non fertilized controls
w.comb<-c()
theat.comb<-c()
mu.comb<-c()
QT.comb<-c()
K.comb<-c()

QB
I2.comb<-c()
p.QT<-c()
p.I2<-c()


#B. zero input controls
w_zf<-mydf.zf$w_zf 
theta.zf<-mydf.zf$ratio_zf; hist(theta.zf); shapiro.test(theta.zf)
mu.zf <- sum(w_zf*theta.zf)/sum(w_zf) #0.2792475; %change 32.21
QT.zf <- sum (w_zf* (theta.zf-mu.zf)^2) #looked up X2 p-value = 0.2236, not sig
K.zf <- length(unique(mydf.zf$ACC)) #39
I2.zf = max ((100*( (QT.zf-(K.zf-1))/QT.zf)),0)
#16% of observed variance can be attribted to difference among the studies

#get p-value, testing backtransformed ratios against X2 distribution with K-1 for df
 1-pchisq(q=QT.zf, df=(K.zf-1)) #ACC is not significant
 1-pchisq(q=I2.zf, df=(K.zf-1)) #ACC not significant - not sure if this test makes statistical sense, just curious
 #16.2% of variance explained by ACC
 

#  p.value = c()
  
#  for(i in 1:ncol(mods1)){
  
#  }
#    ad = adonis(x[factors %in% c(co[1,elem],co[2,elem]),] ~ factors[factors %in% c(co[1,elem],co[2,elem])] , method =sim.method);
#    pairs = c(pairs,paste(co[1,elem],'vs',co[2,elem]));
#    F.Model =c(F.Model,ad$aov.tab[1,4]);
#    R2 = c(R2,ad$aov.tab[1,5]);
#    p.value = c(p.value,ad$aov.tab[1,6])
#  }
#  p.adjusted = p.adjust(p.value,method=p.adjust.m)
#  pairw.res = data.frame(pairs,F.Model,R2,p.value,p.adjusted)
#  return(pairw.res)
#}
##
         
#can also play with boot.mle() for a fitted model
library(FAmle)
#mle() needs to be a 
#boot.mle(all.rma.ar.null)

#check signficant against the X2 distribution:
# http://hamelg.blogspot.com/2015/08/introduction-to-r-part-25-chi-squared.html

#measurements need to be independent = can't test depths?????? 

#mu.hat = sum(w.k*theta.k)/sum(w.k) ; 
#QT = sum (w.k* (theta.k-mu.hat)^2)
#df = # classes * # comparisons -1

#mux.x = boot(data=df.c$ratio_cf, statistic=boot_mean, R=1000, weights=df.c$w_all); plot(results.cf); summary(results.cf) #mean RR = .14995; boot.ci(results.cf)
  
    #ratio <- function(d, w) sum(d$x * w)/sum(d$u * w)
       #boot(city, ratio, R = 999, stype = "w")
  
#Qw= Sum [ (effect - group bootstrapped mean)^2) / SD^2 ]
   #Qw = Sum (theta.x - mu.x)^2) / SD^2 ]
#df = # comparisons -1

#QB= Sum [ group bootstrapped mean - grand bootstrapped mean)^2) / SD^2 ]
#df = # classes -1

#A. fertilized controls
w_cf<-mydf.cf$w_cf 
theta.cf<-mydf.cf$ratio_cf
mu.cf <- sum(w_cf*theta.cf)/sum(w_cf) #0.1495921; % change 16.13
QT.cf <- sum (w_cf* (theta.cf-mu.cf)^2) #not meaningful for random effects models, compare to X2 distrubtion, 50.09 (X2 p-value = .18 , not sig )


 1-pchisq(q=QT.cf, df=(K.cf-1)) #ACC not significant
#create function to resample with
boot_mean <- function(df_vector, resample_indices) {
    mean(df_vector[resample_indices])
}
boot_var <- function(df_vector, resample_indices) {
    (sd(df_vector[resample_indices])^2 )
}
set.seed(12345)
#moderators of interest: exp_duration_mos, amend_group, clay, lat.dec.degree

#############
# example Bootstrap Run data frame with fertilized controls 
##############
#remove rows with NA for response ratio - as these obvs cannot be analyzed
mydf.cf<-df.c[which(!is.na(df.c$ratio_cf)),]  
mean(mydf.cf$ratio_cf) #mean response ratio
#mean(mydf.cf$ratio_cf)-1 #percent change RR=1 no effect (Kallenbach)
mean(mydf.cf$percent.change.cf) #percent change (Pressler 2018)

results.cf <- boot(data=mydf.cf$ratio_cf, statistic=boot_mean, R=1000, weights=mydf.cf$w_cf) # dist looks more evenly distriuted around mean without the weights
                #formula=ratio_cf~depth) #strata=ACC?depth?
plot(results.cf)
summary(results.cf) #mean RR = .14995
boot.ci(results.cf) #,type="bca") #significant if do not inclue 1
 #Percentile 95%   ( 0.1270,  0.1736 )
```





####References
Bootstrap/max likelihood: https://agupubs.onlinelibrary.wiley.com/doi/pdf/10.1029/2001GC000253

Auto correlation rma: https://www.rdocumentation.org/packages/metafor/versions/1.9-9/topics/rma.mv
lmer models with random effects (and intercepts): https://stats.stackexchange.com/questions/31569/questions-about-how-random-effects-are-specified-in-lmer

AIC and BIC explainations:
https://stats.stackexchange.com/questions/81427/aic-guidelines-in-model-selection

```{r, 0. climate data, eval=FALSE}
#http://www.worldclim.org/formats1

#tmean , prec ; 12 data layers 1 for each month
#BIO1 = Annual Mean Temperature; BIO2 = Mean Diurnal Range (Mean of monthly (max temp – min temp)); BIO3 = Isothermality (BIO2/BIO7) (* 100)
#BIO4 = Temperature Seasonality (standard deviation *100); BIO5 = Max Temperature of Warmest Month, BIO6 = Min Temperature of Coldest Month
#BIO7 = Temperature Annual Range (BIO5-BIO6), BIO8 = Mean Temperature of Wettest Quarter, BIO9 = Mean Temperature of Driest Quarter
#BIO10 = Mean Temperature of Warmest Quarter, BIO11 = Mean Temperature of Coldest Quarter, BIO12 = Annual Precipitation
#BIO13 = Precipitation of Wettest Month, BIO14 = Precipitation of Driest Month, BIO15 = Precipitation Seasonality (Coefficient of Variation)
#BIO16 = Precipitation of Wettest Quarter, BIO17 = Precipitation of Driest Quarter, BIO18 = Precipitation of Warmest Quarter, BIO19 = Precipitation of Coldest Quarter

#download resolution of climate data desired: http://worldclim.org/version2 #version 2 = 1970-2000
  #or version 1.4, under generic grid format, downlaod bioclim 2.5 from https://www.worldclim.org/current

#r <- raster::getData("worldclim",var="bio",res=2.5)


# also possible to get future climate data: 
# https://rdrr.io/cran/raster/man/getData.html

#r <- r[[c(1,12)]] #Bio1 and Bio12 selected
#names(r) <- c("Temp","Prec")

#lats <- c(df$lat.dec.degree) #use spTransform if not in WGS 84 lat/lon (EPSG 4326)
#longs <- c(df$long.dec.degree) 
# coords <- data.frame(x=longs,y=lats)

# points <- SpatialPoints(coords, proj4string = r@crs)
# values <- raster::extract(r,points)

#df.clim <- cbind.data.frame(coordinates(points),values); head(df.clim,2)
#df.clim$Temp<-df.clim$Temp/10 #WorldCLim data hs a scale factor of 10 for temp
#WriteXLS(df.clim, "ometa_climate.xls") #specific file here

```

