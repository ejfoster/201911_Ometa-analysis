---
title: "Ometa_Organic_Amendment_Meta_Analysis"
output: html_notebook
editor_options: 
  chunk_output_type: console
---

#### Goal: Meta-analysis on soil organic amendment impact on soil carbon pools > 20cm in depth

mixed model for meta-analysis (regression?) with maximum likelihood 
       (hierarchical w study and depth as groups) OR run different analyssis every 20cm
parameter = carbon stock 
moderators = initial conditions, environment, management
covariate = length of study (months)

I2 test of each moderator?

RESEARCH QUESTIONS
a. Is the effect different from zero? (are there outliers of effect sizes?)
b. Examine degree of heterogeneity of effect sizes
        -Account for between study varition (2nd source of heterogeneity)
c. Estimate standard deviation of studies
       (1) assume normal and S = 1 ; (2) impute from studies with data (SD/mean ratio for complete studies AND (3) regression S = alpha +beta*n)
       
d. Calculate weight of each study (based on sample size of control and trt) (p205)
e. Meta regression (random effect = study), specifically a mixed model,  & test factor influence on the effective size (see list below of 16 factors extracted)
       -metafor mods<-cbind(a, b, c) ; mima (yi, vi, mods, method = "REML")
f. Make statistical inference to derive estimates, test hypothese, make deicions based on the model
       -calculate Q for each moderator? Or calucate I2 (pg 112) 
       -bootstrappping and 95% CI on factors (p 123)
g. Check assumptions
       (1) fit assumptions of statisitcal models
       (2) test publicaiton bias (p219)
       (3) check stat power of tests
       (4) test sensitivity of results to inclusion/exlustion of data - does it change main conclusions
              -imputed SD, estimated 1, only complete studies
              -w and w/out the outliers
              -leave one out (studies or categories)
       (5) check manuscripts (Ch 20)
h. Discuss generaliziability and limitations
        -SE assumed rather than SD when not recorded (more conservative)
i. Gaps where more primary studies are needed?


#### Research Quesitons
Is the overall effect of amendments positive (different from zero) on soil carbon stocks?
How does amendment stabilizaiton of SC change with depth? with time?
Do effects differ between minimum controls vs fertilzed controls?

0 *** Assess correlation of moderators*** -> find a group where moderators are not confounded and run analysis -results are different than the global effects?
Do the following moderators help predict change in soil carbon stocks:
1. Amendment type
2. Amendment rate
3. Amendment C:N ratio
4. C pool  
5. Time since amendment start

Environmental factors
6. MAP
7. MAT
8. MAP/MAT
9. Time since study start
10. **Lattitude**

Initial soil proerpties
11. Texture
12. Initial SOC
13. pH

Management
14. Crop System
15. Irrigation type
16. Fertilizer input


#### Notes:
       #echo=false supresses code; include=false supressed output
COMPLETED
        1) Make categories for each variable = cropping system (monocrop, rotation), crop type (grain, row, legume, forage), years of application, type of amendment, soil pH, SOC content intial, clay content, latitute, C rate applied, dry weight, N rate 
        2) convert SE to SD
        3) Calculated stocks for the df.c data frame only -> no need to calculate the response ratios again, as the BD did not change and they are the same as the C concentraiton ratios
        4) Imputed error in the form of SD with ratios (SD/X'mean') and regrssion SD= alpha +beta (N)
        5) 
```{r, 0.0 climate data, eval=FALSE}
#http://www.worldclim.org/formats1

#tmean , prec ; 12 data layers 1 for each month
#BIO1 = Annual Mean Temperature; BIO2 = Mean Diurnal Range (Mean of monthly (max temp â€“ min temp)); BIO3 = Isothermality (BIO2/BIO7) (* 100)
#BIO4 = Temperature Seasonality (standard deviation *100); BIO5 = Max Temperature of Warmest Month, BIO6 = Min Temperature of Coldest Month
#BIO7 = Temperature Annual Range (BIO5-BIO6), BIO8 = Mean Temperature of Wettest Quarter, BIO9 = Mean Temperature of Driest Quarter
#BIO10 = Mean Temperature of Warmest Quarter, BIO11 = Mean Temperature of Coldest Quarter, BIO12 = Annual Precipitation
#BIO13 = Precipitation of Wettest Month, BIO14 = Precipitation of Driest Month, BIO15 = Precipitation Seasonality (Coefficient of Variation)
#BIO16 = Precipitation of Wettest Quarter, BIO17 = Precipitation of Driest Quarter, BIO18 = Precipitation of Warmest Quarter, BIO19 = Precipitation of Coldest Quarter

#download resolution of climate data desired: http://worldclim.org/version2 #version 2 = 1970-2000
  #or version 1.4, under generic grid format, downlaod bioclim 2.5 from https://www.worldclim.org/current

#r <- raster::getData("worldclim",var="bio",res=2.5)


# also possible to get future climate data: 
# https://rdrr.io/cran/raster/man/getData.html

#r <- r[[c(1,12)]] #Bio1 and Bio12 selected
#names(r) <- c("Temp","Prec")

#lats <- c(df1$lat.dec.degree) #use spTransform if not in WGS 84 lat/lon (EPSG 4326)
#longs <- c(df1$long.dec.degree) 
# coords <- data.frame(x=longs,y=lats)

# points <- SpatialPoints(coords, proj4string = r@crs)
# values <- raster::extract(r,points)

#df.clim <- cbind.data.frame(coordinates(points),values); head(df.clim,2)
#df.clim$Temp<-df.clim$Temp/10 #WorldCLim data hs a scale factor of 10 for temp
#WriteXLS(df.clim, "ometa_climate.xls") #specific file here

```

```{r, 0.1 prelimary - load packages, include=FALSE}
#include=FALSE supress this output when knitting doc
uzdir<-("/Users/macuser/Dropbox/9Meta_analysis_organic/Statistical_meta_analysis/Ometa2019") #save long name as user directory uzdir
setwd(paste(uzdir))  #set your working directory/file
source(file="EJF_libraries.R") #install packages, use old vegan 

#levels(df1$param)
#levels(df1$crop)
#names(df1)
```

```{r, 2. load data and subset, include=FALSE}
#echo=FALSE do not incldue code when knitting doc
#include=FALSE supress this output when knitting doc

#rm(list = ls()) # if you want to reset your environment by deleating everything
df1<-read.csv("Ometa_table.csv", header=T, na.strings= c(""," ", "na", "nd", "NA"), skip=2)
str(df1) 
ncol(df1)
nrow(df1)
#colnames(df1)

#number of studies included
length(unique(df1$ACC))
length(unique(df1$country))
df1$X_a<-as.numeric(df1$X_a); df1$X_cf<-as.numeric(df1$X_cf); df1$X_cmin<-as.numeric(df1$X_cmin)
names(df1)

names(df1)
#select important columns
df1 %>% dplyr::select(X3,ACC, 
                      crop_group, crop_system, irrigation, tillage_type , tillage_depth, till_depth_group, Nfert_rate,
                      depth.start ,  depth.end ,  param ,  param_group ,  units , 
                      time.n.mos,  duration_group,  duration_even , 
                       lat.dec.degree, country , elevation ,  lat_group , MAT ,  MAP ,
                      pH, clay, clay_group ,  pH_group ,  SOC_g.kg, SOC_int_group, BD,
                      amend, amend_group, weight.dry,  C.rate_Mg.ha, C.N_rate, N.amend_g.kg,  
                      X_cf, SE_cf, SD_cf, N_cf, X_a, SE_a, SD_a, N_a, X_cmin, SE_cmin, SD_cmin, N_cmin ) -> df 
  
df1 %>% dplyr::select(X_cf, SE_cf, SD_cf, N_cf, X_a, SE_a, SD_a, N_a, X_cmin, SE_cmin, SD_cmin, N_cmin)-> df.result 

#many data types are extracted, select soil carbon as the initial response parameter
 #subgroups will be used to addresss questions about stability
param<-unique(df1$param)
  df1[which(df1$param=="SOC"|df1$param=="C"), ]$ACC %>% unique() %>% length() #SOC = 49
  

#C = 10
df1[which(df1$param=="SOC"), ]$ACC %>% unique() %>% length() #SOC = 46
#df1[which(df1$param=="POM"| df1$param=="LF"), ]$ACC %>% unique() %>% length() #LF+POM = 4
#df1[which(df1$param=="C_POM"), ]$ACC %>% unique() %>% length() #C_POM = 1
#df1[which(df1$param=="C_MAOM" | df1$param=="MAOM"), ]$ACC %>% unique() %>% length() #C_POM = 3
#df1[which(df1$param=="MAOM"), ]$ACC %>% unique() %>% length() #C_POM = 3 
```

```{r, 3. initial plots, echo=FALSE}
plot(df1$amend_group_brd, df1$C.N_rate) 

plot(df1$country); axis(2,cex.axis=1)  
plot(df1$depth.end)
plot(df1$param_group, main="Parameters - Reponse Variables")
plot(df1$tillage_type, main = "Tillage Groups")
plot(df1$crop_group, main= "Crop Types")
plot(df1$crop_system)
hist(df1$lat.dec.degree, main= "Latitude")
     hist(df1$elevation, main= "Elevation", xlab="Elevation (m)")
     plot(df1$MAP, df1$MAT)
     hist(df1$year.zero, main="First Year of Study", xlab="Year")
     hist(df1$exp_duration_mos, main="Study Length", xlab="Months of Experiment")
      plot(df1$duration_even, main="First Year of Study", xlab="Year")
     hist(df1$MAP, main="Precipitation", xlab="MAP (mm)")
      hist(df1$MAT, main="Temperature", xlab="MAT (degrees C)")
hist(df1$clay, main="Percent Clay", xlab="Clay (%)")
hist(df1$depth.end)
plot(df1$crop_system)
plot(df1$duration_group, main="Study Duration", xlab= "Years")
    plot(df1$irrigation_group, main ="Cateogry of Irrigation")
   plot(df1$till_depth_group, main ="Tillage depths")
   hist(df1$pH, xlab="pH")  
   plot(df1$SOC_int_group, main="Initial SOC", xlab="SOC g/kg")
  
```

```{r, 4. response ratios and weights of ratios, eval=FALSE}
#current dataframess = df and df.result
#calculate SD from SE= SD/ sqrt(n)  => SE*sqrt(n)

#if the value is Na, replace with SD calculated from SE
SD.to.replace<-which(is.na(df$SD_a)); length(SD.to.replace) #of 4079 obs
df$StDev_a<-df$SD_a
df$StDev_a<-ifelse(is.na(df$StDev_a),  #if SD = NA
         df[SD.to.replace ,]$SE_a * sqrt(df[SD.to.replace, ]$N_a), #replace with SE * sqrt of n
       df$StDev_a)

#calculate the weight of each study based off of observation numbers (Hedges adn Olkin 1985)
  df$w.cf<-(df$N_a*df$N_cf)/(df$N_a+df$N_cf)
  df$w.min<-(df$N_a*df$N_cmin)/(df$N_a+df$N_cmin)

#calculate response ratio for each observation:
ratio_min<-log(df$X_a/df$X_cmin)
   nan.check<-df[which(is.nan(ratio_min)), ]; names(nan.check) #determine which values are NaN
   nan.check[c(6, 24:ncol(nan.check))] #print which values are NaN
    percent.change.min<-(exp(ratio_min) -1)*100 #mean % change = (e^ln(rr)-1)*100
    
ratio_fert<-log(df$X_a/df1$X_cf)
    percent.change.fert<-(exp(ratio_fert)-1)*100 

#create new df2 with ratios calculated for each obs
df2<-cbind(df, ratio_min, percent.change.min, ratio_fert, percent.change.fert) #create df with response ratios

#remove NaNs/ Inf
is.na(df2$ratio_min) <- is.infinite(df2$ratio_min)
is.na(df2$ratio_min) <- is.nan(df2$ratio_min)
is.na(df2$ratio_fert) <- is.infinite(df2$ratio_fert)
is.na(df2$ratio_fert) <- is.nan(df2$fert_min) 
```

```{r, 5. subset and calculate soil carbon stocks}

df.c<-subset(df2, param == "C" |param == "SOC" ) #subset by carbon parameters only, obs=537

#calculate carbon stocks from g.kg  (g.kg/1000)*BD*(depth.end-depth.start) = g/cm2
# Convert to t/ha => g/cm2 * (1Mg/ 1,000,000g)*(1*10^8cm2/ha) = 100
   #(1/1000000)*(1*10^8/1) 
df.c$X_a_stock<-ifelse(df.c$units == "g.kg", 
                       df.c$X_a/1000 * df.c$BD * (df.c$depth.end-df.c$depth.start) * 100, 
                       df.c$X_a/1000) #else divides the kg/ha by 1000 to get Mg/ha
df.c$X_cmin_stock<-ifelse(df.c$units == "g.kg", 
                       df.c$X_cmin/1000 * df.c$BD * (df.c$depth.end-df.c$depth.start) * 100, 
                       df.c$X_cmin/1000) #else divides the kg/ha by 1000 to get Mg/ha
df.c$X_cf_stock<-ifelse(df.c$units == "g.kg", 
                       df.c$X_cf/1000 * df.c$BD * (df.c$depth.end-df.c$depth.start) * 100, 
                       df.c$X_cf/1000) #else divides the kg/ha by 1000 to get Mg/ha
  
#convert error to metric t/ha (or Mg/ha)
df.c$SD_a_stock<-ifelse(df.c$units == "g.kg", 
                       df.c$SD_a/1000 * df.c$BD * (df.c$depth.end-df.c$depth.start) * 100, 
                       df.c$SD_a/1000) #else divides the kg/ha by 1000 to get Mg/ha
df.c$SD_cmin_stock<-ifelse(df.c$units == "g.kg", 
                       df.c$SD_cmin/1000 * df.c$BD * (df.c$depth.end-df.c$depth.start) * 100, 
                       df.c$SD_cmin/1000) #else divides the kg/ha by 1000 to get Mg/ha
df.c$SD_fert_stock<-ifelse(df.c$units == "g.kg", 
                       df.c$SD_cf/1000 * df.c$BD * (df.c$depth.end-df.c$depth.start) * 100, 
                       df.c$SD_cf/1000) #else divides the kg/ha by 1000 to get Mg/ha

mean(df.c$ratio_fert, na.rm=TRUE); 
mean(df.c$ratio_min, na.rm=TRUE)

colnames(df.c)
#check normality of ratio distribution 
df.temp<-df.c
f<-df.temp$ratio_fert
m<-df.temp$ratio_min
hist(f); hist(m)   
qqnorm(f);qqline(f) #1 outlier
qqnorm(m);qqline(m) 
shapiro.test(f) #not normal
shapiro.test(m) #not normal

#where are the outliers? for ratio.min and ratio.fert
#mean.ratio<- df2 %>%
#  group_by(ACC) %>%
#  summarise(mean.f = mean(ratio_fert),
#            mean.min = mean(ratio_min), n= n()); mean.ratio

#mean.ratio<- df2 %>%
#  group_by(ACC) %>%
#summarise_all(funs(mean, n), na.rm = TRUE); mean.ratio
```

```{r, impute error}
#impute error over all depths/amendents for df.c

str(df.c) #525 obs
#estimate ratio to impute error for amend trt / fert control / min control
est.SD.a<-sum(df.c$SD_a, na.rm=T)/sum(df.c$X_a,na.rm=T)
est.SD.cf<-sum(df.c$SD_cf, na.rm=T)/sum(df.c$X_cf, na.rm=T)
est.SD.cmin<-sum(df.c$SD_cmin, na.rm=T)/sum(df.c$X_cmin, na.rm=T)

#ratio of SD/X (est.XXX) * mean to impute error (FYI, must use is.na not df.c$X=="NA" (won't return a TRUE, just na and ifelse doesn't work))
df.c$SD_a_imp<-ifelse(is.na(df.c$SD_a), yes=df.c$X_a*est.SD.a, no=df.c$SD_a)
df.c$SD_cf_imp<-ifelse(is.na(df.c$SD_cf), df.c$X_cf*est.SD.cf, df.c$SD_cf)
df.c$SD_cmin_imp<-ifelse(is.na(df.c$SD_cmin), df.c$X_cmin*est.SD.cmin, df.c$SD_cmin)

#amendment errors reported
error.amend<-(1-length(which(is.na(df.c$StDev_a)))/nrow(df.c))*100; error.amend #36% have error reported

#impute error via regression S = alpha +beta(n)
  lm(df.c$SD_cf ~ df.c$N_cf, na.action=na.omit) #cf intercept/alpha= 26.430 m/beta= -6.166
 lm(df.c$SD_cmin ~ df.c$N_cmin, na.action=na.omit) #cmin intercept/alpha= 12.210 m/beta= -2.461 
  lm(df.c$SD_a ~ df.c$N_a, na.action=na.omit) #a intercept/alpha= 25.731 and m/beta=-5.496

#regression to impute error save as new column
df.c$SD_cf_reg<-ifelse(is.na(df.c$SD_cf), 26.430-6.166*(df.c$N_cf), df.c$SD_cf)
df.c$SD_cmin_reg<-ifelse(is.na(df.c$SD_cmin), 12.210-2.461*(df.c$N_cmin), df.c$SD_cmin)
df.c$SD_a_reg<-ifelse(is.na(df.c$SD_a), 25.731-5.496*(df.c$N_a), df.c$SD_a)

```

```{r, bootstrap for 95% CI, on a single depth}
#can also play with boot.mle() for a fitted model

#create one depth variable
df.c$depth<-(df.c$depth.end+df.c$depth.start)/2
#df.sub<-subset(df.c, depth <= 20); length(df.sub) #subset by depth

#create function to resample with
boot_mean <- function(df_vector, resample_indices) {
    mean(df_vector[resample_indices])
}
set.seed(12345)
#moderators of interest: exp_duration_mos, amend_group, clay, lat.dec.degree

#############
#data frame control fertilized
##############
#remove rows with NA for response ratio - as these obvs cannot be analyzed
mydf.fert<-df.c[which(!is.na(df.c$ratio_fert)),]  
mean(mydf.fert$ratio_fert) #mean response ratio
#mean(mydf.fert$ratio_fert)-1 #percent change RR=1 no effect (Kallenbach)
mean(mydf.fert$percent.change.fert) #percent change (Pressler 2018)

results.fert <- boot(data=mydf.fert$ratio_fert, statistic=boot_mean, R=1000, weights=mydf.fert$w.cf) # dist looks more evenly distriuted around mean without the weights
                #formula=ratio_fert~depth) #strata=ACC?depth?
plot(results.fert)
summary(results.fert) #mean RR = .14995
boot.ci(results.fert) #,type="bca") #significant if do not inclue 1
 #Percentile 95%   ( 0.1270,  0.1736 )

#############
#data frame control zero/minimum inputs
##############
mydf.min<-df.c[which(!is.na(df.c$ratio_min)),]
#moderators of interest: exp_duration_mos, amend_group, clay, lat.dec.degree
 
mean(mydf.min$ratio_min) # mean RR
#mean(mydf.min$ratio_min)-1 #percent change (Kallenbach 2011)
mean(mydf.min$percent.change.min) #percent change (Pressler 2018)

#create function to resample with
  #missing 4 weights - need

results.min <- boot(data=mydf.min$ratio_min, statistic=boot_mean, R=1000) #, weights=mydf.min$w.min) #missing 4 weights
                #formula=ratio_fert~depth) #strata=ACC?depth?
plot(results.min)
boot.ci(results.min) #,type="bca")

```

```{r, check for correlation among parameters}
colnames(df1)
hist(df.c$depth.end) 

hist(df.c$depth)  

#pH and MAT?
param.corr<-select(df1, MAT, MAP, lat.dec.degree, elevation, pH, clay, SOC_g.kg)
pear<-rcorr(as.matrix(param.corr), type = "pearson") 
 
```

```{r, mixed-effect meta-analysis (regression) }
#Auto correlation rma: https://www.rdocumentation.org/packages/metafor/versions/1.9-9/topics/rma.mv
names(df.c)

#fertilized control studies
cf.rma.ar <- rma.mv(data=mydf.fert, ratio_fert ~ MAP+clay+amend_group , random= ~depth|ACC,   V=SD_cf_imp, W= w.cf, method="REML", struct="AR") ; cf.rma.ar

min.rma1 <- rma.mv(data=df.sub, ratio_min ~ MAP+clay+amend_group,  V=SD_cmin_imp, W=w.min, method="REML") #level=95 
min.rma1

cf.rma1 <- rma.mv(data=df.sub, ratio_fert ~ MAP+clay+amend_group,  V=SD_cf_imp, W=w.cf, method="REML") #level=95 
cf.rma1

cf.rma1 <- rma.mv(data=df.sub, ratio_cf ~ weight.dry , random= ~depth|ACC,   V=SD_cf_imp, W= w.cf, method="REML", struct="AR") #level=95 

#from github Gurevitch et al https://github.com/KatharinaGerstner/LUBDES_MA
#rma.mv(yi=Log.RR, V=M.matrix(modelDataRichness)+diag(Log.RR.Var),                                    mods=~LUI.range.level-1, 
#                                random = list(~1|Study.Case, ~1|Study.ID),
#                             slab=paste(Study.Case, Low.LUI, High.LUI,sep="_"),
#                    method="REML", tdist=FALSE, level=95,digits=4,data=modelDataRichness)       
### Viechtbauer 2015 p 189: the random argument can also contain one (and only one!) formula of the form ~ inner | outer . 
###   Effects or outcomes with different values/levels of the outer grouping variable/factor are assumed to be 
###   independent, while effects or outcomes with the same value/level of the outer grouping variable/factor share 
###   correlated random effects corresponding to the levels of the inner grouping variable/factor
#calcualte response ratio per parameter per study
df %>% 
  group_by(ACC, param) %>%
  mutate(rr.min = log(df$X_a/df$X_cmin), rr.fert = log(df$X_a/df$X_cf))
  #summarise_each(funs(mean), Cancelled, Diverted)
```


```{r, determine ranges, eval=FALSE}
df<-df2

#crop
levels(df$crop)

#crop_system

#depth.end
#amend
#irrigaiton
#country
#lat.long
#eleveation
#MAP_av
#MAT_av
#soil.texture
#clay
#pH
#SOC_int
#C.rate


```


#### Previous analyses
Additional code is also saved within the .Rmd script from previous statistical analyses for easy access.
```{r, C linear regression models / ANOVA, eval=FALSE, echo=FALSE}
#test without vineyard age as fixed effect
lm.c<-lm (log(C) ~ veg_age*sample_position*layer_bot, data=df.vine)
  resid.clm<- resid(lm.c) #plot residual
  plot(resid.clm);abline(0,0) #look normal 
anova(lm.c) #run analysis of variance, ddf = posthoc correction for mixed model

 #model selection
# Fit the full model 
full.model.c <- lm(sqrt(C) ~ veg_age*layer_bot*sample_position, data=df.vine)
# Stepwise regression model
step.model.c <- stepAIC(full.model.c, direction = "both", trace = FALSE)
summary(step.model.c)

#pairwise contrasts lmer
cont3<-lsmeans(lmer.c, pairwise ~ sample_position*layer_bot);
cont3.table<-summary(cont3$contrasts); cont3.table
cont3.table[(cont3.table$p.value<=.05),]

#pairwise contrasts lm (vine age as a random treatment effect)
cont1<-lsmeans(lm.c, pairwise ~ sample_position*layer_bot|veg_age);
cont1.table<-summary(cont1$contrasts); cont1.table
cont1.table[(cont1.table$p.value<=.05),]

cont2<-lsmeans(lm.c, pairwise ~ veg_age*layer_bot|sample_position);
cont2.table<-summary(cont2$contrasts); cont2.table
cont2.table[(cont2.table$p.value<=.05),]
```


####References
Bootstrap/max likelihood: https://agupubs.onlinelibrary.wiley.com/doi/pdf/10.1029/2001GC000253
